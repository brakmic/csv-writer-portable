{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://CsvWriter/./src/lib/csv-stringifier-factory.ts","webpack://CsvWriter/./src/lib/csv-stringifiers/abstract.ts","webpack://CsvWriter/./src/lib/csv-stringifiers/array.ts","webpack://CsvWriter/./src/lib/csv-stringifiers/object.ts","webpack://CsvWriter/./src/lib/csv-writer-factory.ts","webpack://CsvWriter/./src/lib/csv-writer.ts","webpack://CsvWriter/./src/lib/field-stringifier.ts","webpack://CsvWriter/./src/lib/file-writer.ts","webpack://CsvWriter/./src/lib/lang/object.ts","webpack://CsvWriter/./src/lib/lang/promise.ts","webpack://CsvWriter/webpack/bootstrap","webpack://CsvWriter/./src/index.ts"],"sourcesContent":["import { ArrayCsvStringifier } from './csv-stringifiers/array';\nimport { createFieldStringifier } from './field-stringifier';\nimport { ObjectCsvStringifier } from './csv-stringifiers/object';\nimport { Field, ObjectStringifierHeader } from './record';\n\nexport interface ArrayCsvStringifierParams {\n    header?: string[];\n    fieldDelimiter?: string;\n    recordDelimiter?: string;\n    alwaysQuote?: boolean;\n    quoteEmptyFields?: boolean;\n    filterFunction?: (value: Field) => Field;\n}\n\nexport interface ObjectCsvStringifierParams {\n    header: ObjectStringifierHeader;\n    fieldDelimiter?: string;\n    recordDelimiter?: string;\n    headerIdDelimiter?: string;\n    alwaysQuote?: boolean;\n    quoteEmptyFields?: boolean;\n    filterFunction?: (value: Field) => Field;\n}\n\nexport class CsvStringifierFactory {\n    createArrayCsvStringifier(\n        params: ArrayCsvStringifierParams,\n    ): ArrayCsvStringifier {\n        const fieldStringifier = createFieldStringifier(\n            params.fieldDelimiter,\n            params.alwaysQuote,\n            params.quoteEmptyFields,\n            params.filterFunction\n                ? params.filterFunction\n                : (value: Field) => value,\n        );\n        return new ArrayCsvStringifier(\n            fieldStringifier,\n            params.recordDelimiter,\n            params.header,\n        );\n    }\n\n    createObjectCsvStringifier(\n        params: ObjectCsvStringifierParams,\n    ): ObjectCsvStringifier {\n        const fieldStringifier = createFieldStringifier(\n            params.fieldDelimiter,\n            params.alwaysQuote,\n            params.quoteEmptyFields,\n            params.filterFunction\n                ? params.filterFunction\n                : (value: Field) => value,\n        );\n        return new ObjectCsvStringifier(\n            fieldStringifier,\n            params.header,\n            params.recordDelimiter,\n            params.headerIdDelimiter,\n        );\n    }\n}\n","import {FieldStringifier} from '../field-stringifier'\nimport {Field} from '../record'\n\nconst DEFAULT_RECORD_DELIMITER = '\\n'\nconst VALID_RECORD_DELIMITERS = [DEFAULT_RECORD_DELIMITER, '\\r\\n']\n\nexport abstract class CsvStringifier<T> {\n\n    constructor(private readonly fieldStringifier: FieldStringifier,\n                private readonly recordDelimiter = DEFAULT_RECORD_DELIMITER) {\n        _validateRecordDelimiter(recordDelimiter)\n    }\n\n    getHeaderString(): string | null {\n        const headerRecord = this.getHeaderRecord()\n        return headerRecord ? this.joinRecords([this.getCsvLine(headerRecord)]) : null\n    }\n\n    stringifyRecords(records: IterableIterator<T> | T[]): string {\n        const csvLines = Array.from(records, record => this.getCsvLine(this.getRecordAsArray(record)))\n        return this.joinRecords(csvLines)\n    }\n\n    protected abstract getRecordAsArray(_record: T): Field[]\n\n    protected abstract getHeaderRecord(): string[] | null | undefined\n\n    private getCsvLine(record: Field[]): string {\n        return record\n            .map(fieldValue => this.fieldStringifier.stringify(fieldValue))\n            .join(this.fieldStringifier.fieldDelimiter)\n    }\n\n    private joinRecords(records: string[]) {\n        return records.join(this.recordDelimiter) + this.recordDelimiter\n    }\n}\n\nfunction _validateRecordDelimiter(delimiter: string): void {\n    if (VALID_RECORD_DELIMITERS.indexOf(delimiter) === -1) {\n        throw new Error(`Invalid record delimiter \\`${delimiter}\\` is specified`)\n    }\n}\n","import {CsvStringifier} from './abstract'\nimport {FieldStringifier} from '../field-stringifier'\nimport {Field} from '../record'\n\nexport class ArrayCsvStringifier extends CsvStringifier<Field[]> {\n\n    constructor(fieldStringifier: FieldStringifier,\n                recordDelimiter?: string,\n                private readonly header?: string[]) {\n        super(fieldStringifier, recordDelimiter)\n    }\n\n    protected getHeaderRecord() {\n        return this.header\n    }\n\n    protected getRecordAsArray(record: Field[]): Field[] {\n        return record\n    }\n}\n","import {CsvStringifier} from './abstract'\nimport {FieldStringifier} from '../field-stringifier'\nimport {Field, ObjectHeaderItem, ObjectStringifierHeader} from '../record'\nimport {isObject, ObjectMap} from '../lang/object'\n\nexport class ObjectCsvStringifier extends CsvStringifier<ObjectMap<Field>> {\n\n    constructor(fieldStringifier: FieldStringifier,\n                private readonly header: ObjectStringifierHeader,\n                recordDelimiter?: string,\n                private readonly headerIdDelimiter?: string) {\n        super(fieldStringifier, recordDelimiter)\n    }\n\n    protected getHeaderRecord(): string[] | null {\n        if (!this.isObjectHeader) return null\n        return (this.header as ObjectHeaderItem[]).map(field => field.title)\n    }\n\n    protected getRecordAsArray(record: ObjectMap<Field>): Field[] {\n        return this.fieldIds.map(fieldId => this.getNestedValue(record, fieldId))\n    }\n\n    private getNestedValue(obj: ObjectMap<Field>, key: string) {\n        if (!this.headerIdDelimiter) return obj[key]\n        return key.split(this.headerIdDelimiter).reduce((subObj, keyPart) => (subObj || {})[keyPart], obj)\n    }\n\n    private get fieldIds(): string[] {\n        return this.isObjectHeader ? (this.header as ObjectHeaderItem[]).map(column => column.id) : (this.header as string[])\n    }\n\n    private get isObjectHeader(): boolean {\n        return isObject(this.header && this.header[0])\n    }\n}\n","import { CsvWriter } from './csv-writer';\nimport { CsvStringifierFactory } from './csv-stringifier-factory';\nimport { Field, ObjectStringifierHeader } from './record';\nimport { ObjectMap } from './lang/object';\n\nexport interface ArrayCsvWriterParams {\n    path: string;\n    header?: string[];\n    fieldDelimiter?: string;\n    recordDelimiter?: string;\n    alwaysQuote?: boolean;\n    encoding?: string;\n    append?: boolean;\n    quoteEmptyFields?: boolean;\n    filterFunction?: (value: Field) => Field;\n}\n\nexport interface ObjectCsvWriterParams {\n    path: string;\n    header: ObjectStringifierHeader;\n    fieldDelimiter?: string;\n    recordDelimiter?: string;\n    headerIdDelimiter?: string;\n    alwaysQuote?: boolean;\n    encoding?: string;\n    append?: boolean;\n    quoteEmptyFields?: boolean;\n    filterFunction?: (value: Field) => Field;\n}\n\nexport class CsvWriterFactory {\n    constructor(\n        private readonly csvStringifierFactory: CsvStringifierFactory,\n    ) {}\n\n    createArrayCsvWriter<T = unknown>(\n        params: ArrayCsvWriterParams,\n    ): CsvWriter<T[]> {\n        const csvStringifier =\n            this.csvStringifierFactory.createArrayCsvStringifier({\n                header: params.header,\n                fieldDelimiter: params.fieldDelimiter,\n                recordDelimiter: params.recordDelimiter,\n                alwaysQuote: params.alwaysQuote,\n                quoteEmptyFields: params.quoteEmptyFields,\n                filterFunction: params.filterFunction,\n            });\n        return new CsvWriter<T[]>(\n            csvStringifier,\n            params.path,\n            params.encoding,\n            params.append,\n        );\n    }\n\n    createObjectCsvWriter<T = unknown>(\n        params: ObjectCsvWriterParams,\n    ): CsvWriter<ObjectMap<T>> {\n        const csvStringifier =\n            this.csvStringifierFactory.createObjectCsvStringifier({\n                header: params.header,\n                fieldDelimiter: params.fieldDelimiter,\n                recordDelimiter: params.recordDelimiter,\n                headerIdDelimiter: params.headerIdDelimiter,\n                alwaysQuote: params.alwaysQuote,\n                quoteEmptyFields: params.quoteEmptyFields,\n                filterFunction: params.filterFunction,\n            });\n        return new CsvWriter<ObjectMap<T>>(\n            csvStringifier,\n            params.path,\n            params.encoding,\n            params.append,\n        );\n    }\n}\n","import { CsvStringifier } from './csv-stringifiers/abstract';\nimport { FileWriter } from './file-writer';\n\nconst DEFAULT_INITIAL_APPEND_FLAG = false;\n\nexport interface IFileWriter {\n    write(string: string): Promise<void>;\n}\n\nexport class CsvWriter<T> {\n    private readonly fileWriter: IFileWriter;\n\n    constructor(\n        private readonly csvStringifier: CsvStringifier<T>,\n        path: string,\n        encoding?: string,\n        private append = DEFAULT_INITIAL_APPEND_FLAG,\n        useBom = false,\n        fileWriter?: IFileWriter,\n    ) {\n        this.fileWriter =\n            fileWriter || new FileWriter(path, this.append, encoding, useBom);\n    }\n\n    async writeRecords(records: T[]): Promise<void> {\n        const recordsString = this.csvStringifier.stringifyRecords(records);\n        const writeString = this.headerString + recordsString;\n        await this.fileWriter.write(writeString);\n        this.append = true;\n    }\n\n    private get headerString(): string {\n        const headerString =\n            !this.append && this.csvStringifier.getHeaderString();\n        return headerString || '';\n    }\n}\n","import { Field } from './record';\n\nexport const DEFAULT_FIELD_DELIMITER = ',';\nexport const VALID_FIELD_DELIMITERS = [DEFAULT_FIELD_DELIMITER, ';', '|', '\\t'];\n\nexport abstract class FieldStringifier {\n    constructor(\n        public readonly fieldDelimiter: string,\n        public readonly quoteEmptyFields: boolean = false,\n        public readonly filterFunction: (value: Field) => Field = (value) =>\n            value,\n    ) {}\n\n    abstract stringify(value?: Field): string;\n\n    protected isEmpty(value?: Field): boolean {\n        return typeof value === 'undefined' || value === null || value === '';\n    }\n\n    protected quoteField(field: string): string {\n        return `\"${field.replace(/\"/g, '\"\"')}\"`;\n    }\n\n    protected filterValue(value: Field): Field {\n        return this.filterFunction(value);\n    }\n}\n\nclass DefaultFieldStringifier extends FieldStringifier {\n    stringify(value?: Field): string {\n        const filteredValue = this.filterValue(value);\n        if (this.isEmpty(filteredValue)) {\n            if (this.quoteEmptyFields) return '\"\"';\n            return '';\n        }\n        const str = String(filteredValue);\n        return this.needsQuote(str) ? this.quoteField(str) : str;\n    }\n\n    private needsQuote(str: string): boolean {\n        return (\n            str.includes(this.fieldDelimiter) ||\n            str.includes('\\r') ||\n            str.includes('\\n') ||\n            str.includes('\"')\n        );\n    }\n}\n\nclass ForceQuoteFieldStringifier extends FieldStringifier {\n    stringify(value?: Field): string {\n        const filteredValue = this.filterValue(value);\n        if (this.isEmpty(filteredValue)) {\n            if (this.quoteEmptyFields) return '\"\"';\n            return '';\n        }\n        const str = String(filteredValue);\n        return this.quoteField(str);\n    }\n}\n\nexport function createFieldStringifier(\n    fieldDelimiter: string = DEFAULT_FIELD_DELIMITER,\n    alwaysQuote = false,\n    quoteEmptyFields = false,\n    filterFunction: (value: Field) => Field = (value) => value,\n) {\n    _validateFieldDelimiter(fieldDelimiter);\n    return alwaysQuote\n        ? new ForceQuoteFieldStringifier(\n              fieldDelimiter,\n              quoteEmptyFields,\n              filterFunction,\n          )\n        : new DefaultFieldStringifier(\n              fieldDelimiter,\n              quoteEmptyFields,\n              filterFunction,\n          );\n}\n\nfunction _validateFieldDelimiter(delimiter: string): void {\n    if (VALID_FIELD_DELIMITERS.indexOf(delimiter) === -1) {\n        throw new Error(\n            `Invalid field delimiter \\`${delimiter}\\` is specified`,\n        );\n    }\n}\n","import { promisify } from './lang/promise';\nimport { writeFile } from 'fs';\n\nconst writeFilePromise = promisify(writeFile);\n\nconst DEFAULT_ENCODING = 'utf8';\nconst UTF8_BOM = '\\uFEFF';\n\nexport class FileWriter {\n    constructor(\n        private readonly path: string,\n        private append: boolean,\n        private readonly encoding = DEFAULT_ENCODING,\n        private readonly useBom = false,\n    ) {}\n\n    async write(string: string): Promise<void> {\n        const content =\n            this.useBom && !this.append ? UTF8_BOM + string : string;\n        await writeFilePromise(this.path, content, this.getWriteOption());\n        this.append = true;\n    }\n\n    private getWriteOption() {\n        return {\n            encoding: this.encoding,\n            flag: this.append ? 'a' : 'w',\n        };\n    }\n}\n","export const isObject = (value: any) =>\n    Object.prototype.toString.call(value) === '[object Object]'\n\nexport interface ObjectMap<T> {\n    [k: string]: T\n}\n","\ntype NullableError = Error | null\n\nexport function promisify(fn: (...args: any[]) => void): (...args: any[]) => any {\n    return (...args: any[]) => {\n        return new Promise((resolve, reject) => {\n            const nodeCallback = (err: NullableError, result: any) => {\n                if (err) reject(err)\n                else resolve(result)\n            }\n            fn.apply(null, [...args, nodeCallback])\n        })\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {\n    ArrayCsvStringifierParams,\n    CsvStringifierFactory,\n    ObjectCsvStringifierParams\n} from './lib/csv-stringifier-factory'\nimport { ArrayCsvStringifier } from './lib/csv-stringifiers/array'\nimport { ObjectCsvStringifier } from './lib/csv-stringifiers/object'\nimport { CsvWriter } from './lib/csv-writer'\nimport {ArrayCsvWriterParams, CsvWriterFactory, ObjectCsvWriterParams} from './lib/csv-writer-factory'\nimport { ObjectMap } from './lib/lang/object'\n\nconst csvStringifierFactory = new CsvStringifierFactory()\nconst csvWriterFactory = new CsvWriterFactory(csvStringifierFactory)\n\nexport const createArrayCsvStringifier = (params: ArrayCsvStringifierParams): ArrayCsvStringifier =>\n        csvStringifierFactory.createArrayCsvStringifier(params)\n\nexport const createObjectCsvStringifier = (params: ObjectCsvStringifierParams): ObjectCsvStringifier =>\n        csvStringifierFactory.createObjectCsvStringifier(params)\n\nexport const createArrayCsvWriter = (params: ArrayCsvWriterParams): CsvWriter<any[]> =>\n        csvWriterFactory.createArrayCsvWriter(params)\n\nexport const createObjectCsvWriter = (params: ObjectCsvWriterParams): CsvWriter<ObjectMap<any>> =>\n        csvWriterFactory.createObjectCsvWriter(params)\n"],"names":["createArrayCsvStringifier","params","fieldStringifier","createFieldStringifier","fieldDelimiter","alwaysQuote","quoteEmptyFields","filterFunction","value","ArrayCsvStringifier","recordDelimiter","header","createObjectCsvStringifier","ObjectCsvStringifier","headerIdDelimiter","CsvStringifierFactory","VALID_RECORD_DELIMITERS","delimiter","indexOf","Error","_validateRecordDelimiter","getHeaderString","headerRecord","this","getHeaderRecord","joinRecords","getCsvLine","stringifyRecords","records","csvLines","Array","from","record","getRecordAsArray","map","fieldValue","stringify","join","CsvStringifier","isObjectHeader","field","title","fieldIds","fieldId","getNestedValue","obj","key","split","reduce","subObj","keyPart","column","id","isObject","csvStringifierFactory","createArrayCsvWriter","csvStringifier","CsvWriter","path","encoding","append","createObjectCsvWriter","CsvWriterFactory","useBom","fileWriter","FileWriter","writeRecords","recordsString","writeString","headerString","write","DEFAULT_FIELD_DELIMITER","VALID_FIELD_DELIMITERS","_validateFieldDelimiter","ForceQuoteFieldStringifier","DefaultFieldStringifier","isEmpty","quoteField","replace","filterValue","FieldStringifier","filteredValue","str","String","needsQuote","includes","writeFilePromise","promisify","writeFile","string","content","getWriteOption","flag","Object","prototype","toString","call","fn","Promise","resolve","reject","apply","args","err","result","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","csvWriterFactory"],"sourceRoot":""}
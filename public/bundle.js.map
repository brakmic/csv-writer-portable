{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://CsvWriter/./src/lib/csv-stringifier-factory.ts","webpack://CsvWriter/./src/lib/csv-stringifiers/abstract.ts","webpack://CsvWriter/./src/lib/csv-stringifiers/array.ts","webpack://CsvWriter/./src/lib/csv-stringifiers/object.ts","webpack://CsvWriter/./src/lib/csv-writer-factory.ts","webpack://CsvWriter/./src/lib/csv-writer.ts","webpack://CsvWriter/./src/lib/field-stringifier.ts","webpack://CsvWriter/./src/lib/file-writer.ts","webpack://CsvWriter/./src/lib/lang/object.ts","webpack://CsvWriter/./src/lib/lang/promise.ts","webpack://CsvWriter/webpack/bootstrap","webpack://CsvWriter/./src/index.ts"],"sourcesContent":["import { ArrayCsvStringifier } from './csv-stringifiers/array';\nimport { createFieldStringifier } from './field-stringifier';\nimport { ObjectCsvStringifier } from './csv-stringifiers/object';\nimport { ObjectStringifierHeader } from './record';\n\nexport interface ArrayCsvStringifierParams {\n    header?: string[];\n    fieldDelimiter?: string;\n    recordDelimiter?: string;\n    alwaysQuote?: boolean;\n    filterFunction?: (str: string) => string;\n}\n\nexport interface ObjectCsvStringifierParams {\n    header: ObjectStringifierHeader;\n    fieldDelimiter?: string;\n    recordDelimiter?: string;\n    headerIdDelimiter?: string;\n    alwaysQuote?: boolean;\n    filterFunction?: (str: string) => string;\n}\n\nexport class CsvStringifierFactory {\n    createArrayCsvStringifier(\n        params: ArrayCsvStringifierParams,\n    ): ArrayCsvStringifier {\n        const fieldStringifier = createFieldStringifier(\n            params.fieldDelimiter,\n            params.alwaysQuote,\n            params.filterFunction\n                ? params.filterFunction\n                : (str: string) => str,\n        );\n        return new ArrayCsvStringifier(\n            fieldStringifier,\n            params.recordDelimiter,\n            params.header,\n        );\n    }\n\n    createObjectCsvStringifier(\n        params: ObjectCsvStringifierParams,\n    ): ObjectCsvStringifier {\n        const fieldStringifier = createFieldStringifier(\n            params.fieldDelimiter,\n            params.alwaysQuote,\n            params.filterFunction\n                ? params.filterFunction\n                : (str: string) => str,\n        );\n        return new ObjectCsvStringifier(\n            fieldStringifier,\n            params.header,\n            params.recordDelimiter,\n            params.headerIdDelimiter,\n        );\n    }\n}\n","import {FieldStringifier} from '../field-stringifier'\nimport {Field} from '../record'\n\nconst DEFAULT_RECORD_DELIMITER = '\\n'\nconst VALID_RECORD_DELIMITERS = [DEFAULT_RECORD_DELIMITER, '\\r\\n']\n\nexport abstract class CsvStringifier<T> {\n\n    constructor(private readonly fieldStringifier: FieldStringifier,\n                private readonly recordDelimiter = DEFAULT_RECORD_DELIMITER) {\n        _validateRecordDelimiter(recordDelimiter)\n    }\n\n    getHeaderString(): string | null {\n        const headerRecord = this.getHeaderRecord()\n        return headerRecord ? this.joinRecords([this.getCsvLine(headerRecord)]) : null\n    }\n\n    stringifyRecords(records: IterableIterator<T> | T[]): string {\n        const csvLines = Array.from(records, record => this.getCsvLine(this.getRecordAsArray(record)))\n        return this.joinRecords(csvLines)\n    }\n\n    protected abstract getRecordAsArray(_record: T): Field[]\n\n    protected abstract getHeaderRecord(): string[] | null | undefined\n\n    private getCsvLine(record: Field[]): string {\n        return record\n            .map(fieldValue => this.fieldStringifier.stringify(fieldValue))\n            .join(this.fieldStringifier.fieldDelimiter)\n    }\n\n    private joinRecords(records: string[]) {\n        return records.join(this.recordDelimiter) + this.recordDelimiter\n    }\n}\n\nfunction _validateRecordDelimiter(delimiter: string): void {\n    if (VALID_RECORD_DELIMITERS.indexOf(delimiter) === -1) {\n        throw new Error(`Invalid record delimiter \\`${delimiter}\\` is specified`)\n    }\n}\n","import {CsvStringifier} from './abstract'\nimport {FieldStringifier} from '../field-stringifier'\nimport {Field} from '../record'\n\nexport class ArrayCsvStringifier extends CsvStringifier<Field[]> {\n\n    constructor(fieldStringifier: FieldStringifier,\n                recordDelimiter?: string,\n                private readonly header?: string[]) {\n        super(fieldStringifier, recordDelimiter)\n    }\n\n    protected getHeaderRecord() {\n        return this.header\n    }\n\n    protected getRecordAsArray(record: Field[]): Field[] {\n        return record\n    }\n}\n","import {CsvStringifier} from './abstract'\nimport {FieldStringifier} from '../field-stringifier'\nimport {Field, ObjectHeaderItem, ObjectStringifierHeader} from '../record'\nimport {isObject, ObjectMap} from '../lang/object'\n\nexport class ObjectCsvStringifier extends CsvStringifier<ObjectMap<Field>> {\n\n    constructor(fieldStringifier: FieldStringifier,\n                private readonly header: ObjectStringifierHeader,\n                recordDelimiter?: string,\n                private readonly headerIdDelimiter?: string) {\n        super(fieldStringifier, recordDelimiter)\n    }\n\n    protected getHeaderRecord(): string[] | null {\n        if (!this.isObjectHeader) return null\n        return (this.header as ObjectHeaderItem[]).map(field => field.title)\n    }\n\n    protected getRecordAsArray(record: ObjectMap<Field>): Field[] {\n        return this.fieldIds.map(fieldId => this.getNestedValue(record, fieldId))\n    }\n\n    private getNestedValue(obj: ObjectMap<Field>, key: string) {\n        if (!this.headerIdDelimiter) return obj[key]\n        return key.split(this.headerIdDelimiter).reduce((subObj, keyPart) => (subObj || {})[keyPart], obj)\n    }\n\n    private get fieldIds(): string[] {\n        return this.isObjectHeader ? (this.header as ObjectHeaderItem[]).map(column => column.id) : (this.header as string[])\n    }\n\n    private get isObjectHeader(): boolean {\n        return isObject(this.header && this.header[0])\n    }\n}\n","import { CsvWriter } from './csv-writer';\nimport { CsvStringifierFactory } from './csv-stringifier-factory';\nimport { ObjectStringifierHeader } from './record';\nimport { ObjectMap } from './lang/object';\n\nexport interface ArrayCsvWriterParams {\n    path: string;\n    header?: string[];\n    fieldDelimiter?: string;\n    recordDelimiter?: string;\n    alwaysQuote?: boolean;\n    encoding?: string;\n    append?: boolean;\n    filterFunction?: (str: string) => string;\n}\n\nexport interface ObjectCsvWriterParams {\n    path: string;\n    header: ObjectStringifierHeader;\n    fieldDelimiter?: string;\n    recordDelimiter?: string;\n    headerIdDelimiter?: string;\n    alwaysQuote?: boolean;\n    encoding?: string;\n    append?: boolean;\n    filterFunction?: (str: string) => string;\n}\n\nexport class CsvWriterFactory {\n    constructor(\n        private readonly csvStringifierFactory: CsvStringifierFactory,\n    ) {}\n\n    createArrayCsvWriter<T = unknown>(\n        params: ArrayCsvWriterParams,\n    ): CsvWriter<T[]> {\n        const csvStringifier =\n            this.csvStringifierFactory.createArrayCsvStringifier({\n                header: params.header,\n                fieldDelimiter: params.fieldDelimiter,\n                recordDelimiter: params.recordDelimiter,\n                alwaysQuote: params.alwaysQuote,\n                filterFunction: params.filterFunction,\n            });\n        return new CsvWriter<T[]>(\n            csvStringifier,\n            params.path,\n            params.encoding,\n            params.append,\n        );\n    }\n\n    createObjectCsvWriter<T = unknown>(\n        params: ObjectCsvWriterParams,\n    ): CsvWriter<ObjectMap<T>> {\n        const csvStringifier =\n            this.csvStringifierFactory.createObjectCsvStringifier({\n                header: params.header,\n                fieldDelimiter: params.fieldDelimiter,\n                recordDelimiter: params.recordDelimiter,\n                headerIdDelimiter: params.headerIdDelimiter,\n                alwaysQuote: params.alwaysQuote,\n                filterFunction: params.filterFunction,\n            });\n        return new CsvWriter<ObjectMap<T>>(\n            csvStringifier,\n            params.path,\n            params.encoding,\n            params.append,\n        );\n    }\n}\n","import { CsvStringifier } from './csv-stringifiers/abstract';\nimport { FileWriter } from './file-writer';\n\nconst DEFAULT_INITIAL_APPEND_FLAG = false;\n\nexport interface IFileWriter {\n    write(string: string): Promise<void>;\n}\n\nexport class CsvWriter<T> {\n    private readonly fileWriter: IFileWriter;\n\n    constructor(\n        private readonly csvStringifier: CsvStringifier<T>,\n        path: string,\n        encoding?: string,\n        private append = DEFAULT_INITIAL_APPEND_FLAG,\n        fileWriter?: IFileWriter,\n    ) {\n        this.fileWriter =\n            fileWriter || new FileWriter(path, this.append, encoding);\n    }\n\n    async writeRecords(records: T[]): Promise<void> {\n        const recordsString = this.csvStringifier.stringifyRecords(records);\n        const writeString = this.headerString + recordsString;\n        await this.fileWriter.write(writeString);\n        this.append = true;\n    }\n\n    private get headerString(): string {\n        const headerString =\n            !this.append && this.csvStringifier.getHeaderString();\n        return headerString || '';\n    }\n}\n","import { Field } from './record';\n\nconst DEFAULT_FIELD_DELIMITER = ',';\nconst VALID_FIELD_DELIMITERS = [DEFAULT_FIELD_DELIMITER, ';'];\n\nexport abstract class FieldStringifier {\n    constructor(\n        public readonly fieldDelimiter: string,\n        public readonly filterFunction: (str: string) => string = (str) => str,\n    ) {}\n\n    abstract stringify(value?: Field): string;\n\n    protected isEmpty(value?: Field): boolean {\n        return typeof value === 'undefined' || value === null || value === '';\n    }\n\n    protected quoteField(field: string): string {\n        return `\"${field.replace(/\"/g, '\"\"')}\"`;\n    }\n\n    protected filterChars(str: string): string {\n        return this.filterFunction(str);\n    }\n}\n\nclass DefaultFieldStringifier extends FieldStringifier {\n    stringify(value?: Field): string {\n        if (this.isEmpty(value)) return '';\n        let str = String(value);\n        str = this.filterChars(str);\n        return this.needsQuote(str) ? this.quoteField(str) : str;\n    }\n\n    private needsQuote(str: string): boolean {\n        return (\n            str.includes(this.fieldDelimiter) ||\n            str.includes('\\r') ||\n            str.includes('\\n') ||\n            str.includes('\"')\n        );\n    }\n}\n\nclass ForceQuoteFieldStringifier extends FieldStringifier {\n    stringify(value?: Field): string {\n        if (this.isEmpty(value)) return '';\n        let str = String(value);\n        str = this.filterChars(str);\n        return this.quoteField(str);\n    }\n}\n\nexport function createFieldStringifier(\n    fieldDelimiter: string = DEFAULT_FIELD_DELIMITER,\n    alwaysQuote = false,\n    filterFunction: (str: string) => string = (str) => str,\n) {\n    _validateFieldDelimiter(fieldDelimiter);\n    return alwaysQuote\n        ? new ForceQuoteFieldStringifier(fieldDelimiter, filterFunction)\n        : new DefaultFieldStringifier(fieldDelimiter, filterFunction);\n}\n\nfunction _validateFieldDelimiter(delimiter: string): void {\n    if (VALID_FIELD_DELIMITERS.indexOf(delimiter) === -1) {\n        throw new Error(\n            `Invalid field delimiter \\`${delimiter}\\` is specified`,\n        );\n    }\n}\n","import { promisify } from './lang/promise';\nimport { writeFile } from 'fs';\n\nconst writeFilePromise = promisify(writeFile);\n\nconst DEFAULT_ENCODING = 'utf8';\n\nexport class FileWriter {\n    constructor(\n        private readonly path: string,\n        private append: boolean,\n        private readonly encoding = DEFAULT_ENCODING,\n    ) {}\n\n    async write(string: string): Promise<void> {\n        await writeFilePromise(this.path, string, this.getWriteOption());\n        this.append = true;\n    }\n\n    private getWriteOption() {\n        return {\n            encoding: this.encoding,\n            flag: this.append ? 'a' : 'w',\n        };\n    }\n}\n","export const isObject = (value: any) =>\n    Object.prototype.toString.call(value) === '[object Object]'\n\nexport interface ObjectMap<T> {\n    [k: string]: T\n}\n","\ntype NullableError = Error | null\n\nexport function promisify(fn: (...args: any[]) => void): (...args: any[]) => any {\n    return (...args: any[]) => {\n        return new Promise((resolve, reject) => {\n            const nodeCallback = (err: NullableError, result: any) => {\n                if (err) reject(err)\n                else resolve(result)\n            }\n            fn.apply(null, [...args, nodeCallback])\n        })\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {\n    ArrayCsvStringifierParams,\n    CsvStringifierFactory,\n    ObjectCsvStringifierParams\n} from './lib/csv-stringifier-factory'\nimport { ArrayCsvStringifier } from './lib/csv-stringifiers/array'\nimport { ObjectCsvStringifier } from './lib/csv-stringifiers/object'\nimport { CsvWriter } from './lib/csv-writer'\nimport {ArrayCsvWriterParams, CsvWriterFactory, ObjectCsvWriterParams} from './lib/csv-writer-factory'\nimport { ObjectMap } from './lib/lang/object'\n\nconst csvStringifierFactory = new CsvStringifierFactory()\nconst csvWriterFactory = new CsvWriterFactory(csvStringifierFactory)\n\nexport const createArrayCsvStringifier = (params: ArrayCsvStringifierParams): ArrayCsvStringifier =>\n        csvStringifierFactory.createArrayCsvStringifier(params)\n\nexport const createObjectCsvStringifier = (params: ObjectCsvStringifierParams): ObjectCsvStringifier =>\n        csvStringifierFactory.createObjectCsvStringifier(params)\n\nexport const createArrayCsvWriter = (params: ArrayCsvWriterParams): CsvWriter<any[]> =>\n        csvWriterFactory.createArrayCsvWriter(params)\n\nexport const createObjectCsvWriter = (params: ObjectCsvWriterParams): CsvWriter<ObjectMap<any>> =>\n        csvWriterFactory.createObjectCsvWriter(params)\n"],"names":["createArrayCsvStringifier","params","fieldStringifier","createFieldStringifier","fieldDelimiter","alwaysQuote","filterFunction","str","ArrayCsvStringifier","recordDelimiter","header","createObjectCsvStringifier","ObjectCsvStringifier","headerIdDelimiter","CsvStringifierFactory","VALID_RECORD_DELIMITERS","delimiter","indexOf","Error","_validateRecordDelimiter","getHeaderString","headerRecord","this","getHeaderRecord","joinRecords","getCsvLine","stringifyRecords","records","csvLines","Array","from","record","getRecordAsArray","map","fieldValue","stringify","join","CsvStringifier","isObjectHeader","field","title","fieldIds","fieldId","getNestedValue","obj","key","split","reduce","subObj","keyPart","column","id","isObject","csvStringifierFactory","createArrayCsvWriter","csvStringifier","CsvWriter","path","encoding","append","createObjectCsvWriter","CsvWriterFactory","fileWriter","FileWriter","writeRecords","recordsString","writeString","headerString","write","VALID_FIELD_DELIMITERS","_validateFieldDelimiter","ForceQuoteFieldStringifier","DefaultFieldStringifier","DEFAULT_FIELD_DELIMITER","isEmpty","value","quoteField","replace","filterChars","FieldStringifier","String","needsQuote","includes","writeFilePromise","promisify","writeFile","string","getWriteOption","flag","Object","prototype","toString","call","fn","Promise","resolve","reject","apply","args","err","result","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","csvWriterFactory"],"sourceRoot":""}